# ドメイン駆動設計入門　
ボトムアップでわかる！ドメイン駆動設計の基本

### 読む前
- ドメイン駆動設計とは何を指す言葉なのか知りたい。
- チームの生産性を向上させるために設計の基礎知識を身につけたい。
- 設計を理解した開発することで、生産性を今の1.5倍にする。

## ドメイン駆動設計とは
ソフトウェア利用者を取り巻く環境と実装を結びつけるとを目的としている。<br>
※ 知識をコードへ

### ドメイン
> ドメイン　＝　プログラムを適用する対象となる領域<br>
> ※ドメインに含まれるものは何かが重要

> つまり、ドメインが抱える問題と向き合い、理解し、それを解決する

### ドメインモデル
> モデル　　　　　＝　現実の事象や概念を抽象化した概念<br>
> ドメインモデル　＝　ドメインの概念からモデリングされたモデル

※ ペン　＝＞　小説家：小説を書く道具　　文具屋：1つの商品

> ドメインの概念 <=> ドメインモデル <=> ドメインオブジェクト

***

## 値オブジェクト

> 値オブジェクト　＝　システム固有の値

値の性質
- 不変である
- 交換が可能である
- 等価性によって比較される

### 値の交換
「代入」すること
あるクラスが格納された変数の値に新しいインスタンス生成したクラスを「代入」する
```typescript
var a = 0
a     = 1

var fullName = new FullName('Takumi', 'Shimizu')
fullName     = new FullName('Taro', 'Yamada')
```
### 値オブジェクトにするか否か
- そこにルールが存在しているか
- それ単体で扱いたいか

scalaにはEnumという型が存在しており、関数型型付け言語なため上記はかなりなじみ深く表現しやすい印象。<br>
Enumは列挙型なため、列挙したものしか存在し得ないことを担保できる。<br>
しかし、電話番号やメールアドレスなどは値オブジェクト（クラス）として値生成時に評価して、
バリデーションをかけても良いのではないか？？と感じた。

#### 値オブジェクトの振る舞い
値オブジェクトにメソッドを書くことで、それ自身の振る舞いを表現できる。
メソッドを書くことはできることを表現することであり、記載がないことはできないことを暗に表現している。

#### 値オブジェクトを採用するモチベ
値オブジェクトを採用する　＝　クラスを1つ増やす<br>
##### モチベ
- 表現力を増す
- 不正な値を存在させない
- 誤った代入を防ぐ
- ロジックの散在を防ぐ

##### 表現力
値オブジェクト自身がどのような値なのか、主張できる<br>
値オブジェクトにルールや振る舞いをまとめることで、保守メンテがしやすくなり、<br>
結果的にコード自体（値オブジェクト自体）が、ドキュメントとして機能するようになる。

***

## エンティティ

### エンティティとは

- 可変である
- 同じ属性であっても評価される
- 同一性により評価される

> 例：エンティティ　：ユーザー　←　年齢や体重が変わろうとその人自身である<br>
　　値オブジェクト：名前　　　←　姓と名で構成され、それぞれの値が変わると名前自体も別物になる

ある概念がエンティティなのか、値オブジェクトなのかの判断基準は「ライフサイクル」の存在有無<br>
「ライフサイクル」があるかはっきりしない場合は、値オブジェクトとして扱い、不変にしておくと良い。<br>
エンティティは作成されてから削除されるまで、変化する可能性があるためバグの原因となりやすい。<br>
それを防ぐためにも値オブジェクトとして扱い、シンプルなコード（概念）として扱うべきである。

***

## ドメインサービス

> 値オブジェクトやエンティティに定義すると不自然な振る舞いを記述するオブジェクト

例：ユーザー名重複判別<br>
　　※Userクラスに定義するとUserクラス自身に、アクセスすることになり少し不自然。
　　　UserServiceクラスを作成しそこに定義するとよい。

### 注意

> 全ての振る舞いはドメインサービスに記述できてしまうため、値オブジェクトやエンティティに対して定義するべき振る舞いまでまとめて定義できてしまう。<br>
しかし、それでは値オブジェクトやエンティティに対するドメインのルールがわからなくなり、オブジェクト指向からも外れてしまう。<br>
あくまで、値オブジェクトやエンティティに定義すると、不自然な振る舞いのみをドメインサービスに記述するようにする。<br>
振る舞いの定義場所に迷ったときは、値オブジェクトやエンティティに定義するようにする。 

***

## リポジトリ

### リポジトリの責務

> ドメインオブジェクトの永続化や再構築を行うこと。<br>
> 簡単に要約すると、データベースに関連すること。<br>
> 何かのデータの作成・編集・削除などは振る舞いではないため、値オブジェクト、エンティティ、ドメインサービスどれにも適切ではない。<br>
> リポジトリを活用する。

*** 

## アプリケーションサービス

アプリケーション　＝　利用者の目的に応じたプログラム

アプリケーションのチュートリアル
CRUD処理　＝ CREATE, READ, UPDATE, DELETE

> 利用者の目的に応じた機能を集約する

ドメインオブジェクトにルールを記載し、アプリケーションサービスはそれを使用する形に仕立てる。

### 凝集度

モジュールの責任範囲がどれだけ集中しているか図る尺度<br>
凝集度を高めることで、モジュールが1つの事柄に集中することになり、堅牢性・信頼性・再利用性・可読性が向上する。<br>
これを高めることが常に正解とは限らないが、一向の価値はある。

まとまりを表現するために利用するのがパッケージ。<br>
凝集度を意識して目的ごとに振る舞いを分けるとファイル数が多くなるため、パッケージを利用する。

***

## 柔軟性を与える依存関係のコントロール

### 依存関係逆転の原則
> A. 上位レベルのモジュールは下位レベルのモジュールに依存してはならない、どちらのモジュールも抽象に依存するべきである。
> B. 抽象は実装の詳細に依存してはならない。実装の詳細が抽象に依存するべきである。

### プログラムのレベルの概念
> 上位：人間に近い抽象的な処理
> 下位：機械に近い具体的な処理

依存関係のコントロール２パターン
> Service Locator パターン ※依存関係が見えなく、テストが強制的でないため非推奨<br>
> IoC Container(DI Container)パターン

***

## ファクトリ

> オブジェクトの生成に関わる知識がまとめられたオブジェクト

***

## 集約

> 複数のオブジェクトがまとめられ、1つの芋を持ったオブジェクトが構築される。<br>
> このまとまりを集約と呼ぶ。集約には、不変条件が存在する。

※集約の外部から教会の内部のオブジェクトを操作してはいけない。

```typescript
var user  = user("takumi")
user.name = "hoge"      // NG
user.nameChange("hoge") // OK
```

### デメテルの法則

> 外部から内部のオブジェクトを操作する形ではなく、外部から内部のオブジェクトに操作を依頼する形を取ることで直感的に操作でき、不変状態を維持できる。

#### 基本的な原則
メソッドを呼び出すオブジェクトは次の4つに限定される
- オブジェクト自身
- 引数として渡されたオブジェクト
- インスタンス変数
- 直接インスタンスかしたオブジェクト

上記を守りオブジェクト自信がフィールドを管理する形を維持し、振る舞いを制御することで、コードの重複や分散をなくすことができる。

###　言葉との齟齬を無くす。
メンバー30名以上はエラー<br>
member >= 29ではなく<br>
member.count()　>= 30　のようにして<br>
言葉との齟齬がないように実装する。


